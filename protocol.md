1. Запущены два теста: 
    1. "2 1 5 -12 3 -9"
    2. "5 3 2 4 1"
2. Вывод программы не соответсвует ошидаемому в обоих случаях. Замечено, что даже появляются числа, которые не поступали как входные данные
3. Повторим тест с набором "5 3 2 4 1", но, скомпилировав ее с ключом -g и запустив через gdb
4. Ставим break main. И делаем run 5 3 2 4 1
5. Проходим next'ами до обработки массива в shell_sort. Делаем list, для просмотра алгоритма сортировки
6. Добавляем:
    * display a[0]
    * display a[1]
    * display a[2]
    * display a[3]
    * display a[4]
    * display h
    * display i
    * display j
7. Проходя next'ами по циклам видем, что i в какой-то момент становится равной 5, хотя последний индекс элемента в массиве должен быть 4 (всего 5 элементов). Надо понять откуда такие данные
8. Вызываем команду where:
    * #0  shell_sort (a=0x5555555592a0, size=6) at shell-sort.c:8
    * #1  0x000055555555536d in main (argc=6, argv=0x7fffffffe028) at shell-sort.c:36
9. Видим, что size = 6, хотя элементов 5. Кто-то передает неправильные данные при вызове функции
10. Вызваем frame 1:
    * #1  0x000055555555536d in main (argc=6, argv=0x7fffffffe028) at shell-sort.c:36
    * 36	  shell_sort(a, argc);
11. Видим, что функция сортировки вызывается с size = argc == 6, который включает в количество аргументов и названия исполняемого файла. 
12. Ошибка найдена. Нужно передовать size = argc - 1 пи вызове shell_sort.
13. Перекомпилируем заново файл с исходным кодом. Программа работает корректор на обоих тестах: 
    1. "2 1 5 -12 3 -9"
    2. "5 3 2 4 1"
