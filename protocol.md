## [Первая программа](https://github.com/RuslanGaliullin/CAaOS/tree/HW_03/images/01)

Выводил значения регистров, которые лежат в регистрах и сравнивал со значениями в программе, чтобы понять работу mov. Проверял теория устройста регистров al, ax, eax, rax

## [Вторая программа](https://github.com/RuslanGaliullin/CAaOS/tree/HW_03/images/02)

Выводил значения регистров. Смотрел передачу значений из регистров меньшейдлины в большие, зануление старших 32 бит при 32 битной инструкции над ними.

## [Третья программа](https://github.com/RuslanGaliullin/CAaOS/tree/HW_03/images/03)

Квадратные скобки вокруг регистра - обращение по адресу, который хранится в этом регистре. Интересно, что -48[rbp+4*rcx] == -48[4*¬rcx][rbp]

## [Четвертая программа](https://github.com/RuslanGaliullin/CAaOS/tree/HW_03/images/04)

Директивы размера BYTE PTR, WORD PTR и DWORD PTR служат этой цели, указывая размеры 1, 2 и 4 байта соответственно. А команду x/x можно использовать, чтобы смотреть значения по конкретному адресу.

## [Пятая программа](https://github.com/RuslanGaliullin/CAaOS/tree/HW_03/images/05)

Мы перепрыгнули только в forward, потому что jne forward проверяет, что ZF флаг равен 1, а je, наоборот, что нулю. В обоих случаея в rax будет записано ненулевое число => ZF = 0, поэтому будет прыжок только на forward
